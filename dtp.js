/*

Support functions, in Javascript, for the DTP system (see /hhs/dtp.php)


Copyright Â© 2019 Nick Gammon.

  Author: Nick Gammon <nick@gammon.com.au>
  Web:    http://www.gammon.com.au/
  Date:   November 2019

 PERMISSION TO DISTRIBUTE

 Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 and associated documentation files (the "Software"), to deal in the Software without restriction,
 including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 LIMITATION OF LIABILITY

 The software is provided "as is", without warranty of any kind, express or implied,
 including but not limited to the warranties of merchantability, fitness for a particular
 purpose and noninfringement. In no event shall the authors or copyright holders be liable
 for any claim, damages or other liability, whether in an action of contract,
 tort or otherwise, arising from, out of or in connection with the software
 or the use or other dealings in the software.

  Note: The PHP file communicates with this module by passing down variables giving the element ID,
  element type and position of each element. The page width and page height are for converting from
  mm as used in the document and pixels as used on the screen.

  Example:

  var num_elements = 6;
  var page_width = 210;
  var page_height = 297;
  var elements = [
  [ 36, 3, 108, 48, 108, 280 ],
  [ 50, 6, 16, 96, 96, 152 ],
  [ 56, 6, 16, 216, 100, 268 ],
  [ 60, 5, 16, 16, 200, 40 ],
  [ 61, 5, 16, 48, 104, 212 ],
  [ 62, 7, 112, 48, 200, 288 ],
  ];

*/

const BOX_SIZE = 10;   // size of corner boxes
const DRAGGING_BOX_SIZE = 30;  // width of dragging box (height is BOX_SIZE)

// array position meanings (as generated by dtp.php)
const ELEMENT_ID    = 0;
const ELEMENT_TYPE  = 1;
const STARTX        = 2;
const STARTY        = 3;
const ENDX          = 4;
const ENDY          = 5;

const LAST_ITEM = ENDY;  // must be last element in array (above)

// element types
const ELEMENT_RECTANGLE         = 1;
const ELEMENT_ELLIPSE           = 2;
const ELEMENT_LINE              = 3;
const ELEMENT_STAR              = 4;
const ELEMENT_TEXT              = 5;
const ELEMENT_IMAGE             = 6;
const ELEMENT_TEXT_CONTINUATION = 7;

function init()
  {
  canvas = document.getElementById("mycanvas");  // our canvas
  ctx = canvas.getContext("2d");                 // our drawing context
  // convert width from mm into pixels as displayed on the page
  width_multiple = canvas.width / page_width;
  height_multiple = canvas.height / page_height;

  // make a copy of element positions so we can reset to the beginning state
  orig_elements = [];
  for (i = 0; i < num_elements; i++)
    {
    orig_elements [i] = [];
    for (j = 0; j <= LAST_ITEM; j++)
      orig_elements [i] [j] = elements [i] [j];
    }

  // they haven't clicked the "Edit" button yet
  edit_clicked = false;
  edits_done = false;

  } // end of init

// draw one of the four corner boxes
function drawCornerBox (x, y)
  {
  ctx.beginPath();
  ctx.rect((x * width_multiple)   - BOX_SIZE / 2,
           (y * height_multiple)  - BOX_SIZE / 2,
           BOX_SIZE,
           BOX_SIZE
           );
  ctx.fillStyle = "green";
  ctx.fill ();
  } // end of drawCornerBox

// extract out one array element into global variables
function getElementDetails (element)
  {
  // extract out fields from database
  element_id    = element [ELEMENT_ID];
  element_type  = element [ELEMENT_TYPE];
  startX        = element [STARTX];
  startY        = element [STARTY];
  endX          = element [ENDX];
  endY          = element [ENDY];

  } // end of getElementDetails

// draw element borders, plus resizing and moving handles
function drawborders ()
{
ctx.clearRect(0, 0, canvas.width, canvas.height);  // clear canvas
for (i = 0; i < num_elements; i++)
  {
  // get *this* element
  getElementDetails (elements [i]);

  // stroke the entire element (box around it)
  ctx.beginPath();
  ctx.rect(startX * width_multiple, startY * height_multiple, (endX - startX) * width_multiple, (endY - startY) * height_multiple);
  ctx.strokeStyle = "green";
  ctx.stroke();

  // corner boxes (small boxes at corners)
  drawCornerBox (startX, startY);

  // lines only have two corners
  if (element_type != ELEMENT_LINE)
    {
    drawCornerBox (endX, startY);
    drawCornerBox (startX, endY);
    }

  drawCornerBox (endX, endY);

  // draw dragging box
  ctx.beginPath();
  x = startX + ((endX - startX) / 2);  // half way along
  ctx.rect((x * width_multiple) - (DRAGGING_BOX_SIZE / 2),
           (startY * height_multiple)  - BOX_SIZE / 2,
           DRAGGING_BOX_SIZE,
           BOX_SIZE
           );
  ctx.fillStyle = "green";
  ctx.fill ();

  } // end of for each element

} // end of drawborders

// here when the "Reset" button clicked - put everything back to how it was
function ResetClicked (event)
{
  submit_edits_button = document.getElementById("submit_edits_button");
  submit_edits_button.disabled = true;

  reset_edits_button = document.getElementById("reset_edits_button");
  reset_edits_button.disabled = true;

  for (i = 0; i < num_elements; i++)
    {
    // copy values back
    for (j = 0; j <= LAST_ITEM; j++)
      elements [i] [j] = orig_elements [i] [j];

    // put the HTML values back
    element_id = elements [i] [ELEMENT_ID];

    // fix up startX
    startXonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_startX"));
    startXonPage [0].value = elements [i] [STARTX];

    // fix up startY
    startYonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_startY"));
    startYonPage [0].value = elements [i] [STARTY];

    // fix up endX
    endXonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_endX"));
    endXonPage [0].value = elements [i] [ENDX];

    // fix up endY
    endYonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_endY"));
    endYonPage [0].value = elements [i] [ENDY];

    } // end of for each element

  drawborders ();   // redraw original positions
  edits_done = false;
  return false;     // don't submit form
} // end of ResetClicked

// here when the "Edit" / "Submit edits" button is clicked
function SubmitEditsClicked (event)
{
  if (!edit_clicked)
    {
    edit_clicked = true;
    submit_edits_button = document.getElementById("submit_edits_button");
    submit_edits_button.value = "Submit Edits";
    submit_edits_button.disabled = true;  // nothing edited yet
    drawborders ();
    return false;   // don't submit yet
    }
  return true;  // submit form now
} // end of SubmitEditsClicked

// mouse move handler - resize the element box (or move it) assuming we had a previous mouse down
function onMouseMove(event)
{
  if (dragok)
   {
    // find new position in mm
    x = Math.round(event.offsetX / width_multiple);
    y = Math.round(event.offsetY  / height_multiple);

    element_type = elements [activeElement] [ELEMENT_TYPE];

    // update element - depending on which corner was being moved

    // top left
    if (activeCorner == 'topleft' && element_type == ELEMENT_LINE)
      {
      // lines can line up vertically and horizontally
      if (x <= elements [activeElement] [ENDX] && y <= elements [activeElement] [ENDY])
        {
        elements [activeElement] [STARTX] = x;
        elements [activeElement] [STARTY] = y;
        }
      }
    else if (activeCorner == 'topleft' && element_type != ELEMENT_LINE)
      {
      if (x < elements [activeElement] [ENDX] && y < elements [activeElement] [ENDY])
        {
        elements [activeElement] [STARTX] = x;
        elements [activeElement] [STARTY] = y;
        }
      }

    // top right
    else if (activeCorner == 'topright')
      {
      if (x > elements [activeElement] [STARTX] && y < elements [activeElement] [ENDY])
        {
        elements [activeElement] [ENDX] = x;
        elements [activeElement] [STARTY] = y;
        }
      }

    // bottom left
    else if (activeCorner == 'bottomleft')
      {
      if (x < elements [activeElement] [ENDX] && y > elements [activeElement] [STARTY])
        {
        elements [activeElement] [STARTX] = x;
        elements [activeElement] [ENDY] = y;
        }
      }

   // bottom right
   else if (activeCorner == 'bottomright' && element_type == ELEMENT_LINE)
      {
      // lines can line up vertically and horizontally
      if (x >= elements [activeElement] [STARTX] && y >= elements [activeElement] [STARTY])
        {
        elements [activeElement] [ENDX] = x;
        elements [activeElement] [ENDY] = y;
        }
      }
   else if (activeCorner == 'bottomright' && element_type != ELEMENT_LINE)
      {
      if (x > elements [activeElement] [STARTX] && y > elements [activeElement] [STARTY])
        {
        elements [activeElement] [ENDX] = x;
        elements [activeElement] [ENDY] = y;
        }
      }

    // drag box (reposition)
    else if (activeCorner == 'drag')
      {
      deltaX = Math.round((dragMouseX - event.offsetX) / width_multiple);
      deltaY = Math.round((dragMouseY - event.offsetY) / height_multiple);
      elements [activeElement] [STARTX] = dragStartX - deltaX;
      elements [activeElement] [STARTY] = dragStartY - deltaY;
      elements [activeElement] [ENDX]   = dragEndX   - deltaX;
      elements [activeElement] [ENDY]   = dragEndY   - deltaY;
      }

    drawborders ();

    // update form ready for them to post it

    // turn element array number into an element ID
    element_id = elements [activeElement] [ELEMENT_ID];

    // fix up startX
    startXonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_startX"));
    startXonPage [0].value = elements [activeElement] [STARTX];

    // fix up startY
    startYonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_startY"));
    startYonPage [0].value = elements [activeElement] [STARTY];

    // fix up endX
    endXonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_endX"));
    endXonPage [0].value = elements [activeElement] [ENDX];

    // fix up endY
    endYonPage = document.getElementsByName("element_".concat (element_id.toString (10), "_endY"));
    endYonPage [0].value = elements [activeElement] [ENDY];

    submit_edits_button = document.getElementById("submit_edits_button");
    reset_edits_button = document.getElementById("reset_edits_button");

    // check a change has actually been made before activating the submit and reset buttons
    if (elements [activeElement] [STARTX] != orig_elements [activeElement] [STARTX] ||
        elements [activeElement] [ENDX]   != orig_elements [activeElement] [ENDX] ||
        elements [activeElement] [STARTY] != orig_elements [activeElement] [STARTY] ||
        elements [activeElement] [ENDY]   != orig_elements [activeElement] [ENDY])
      {
      submit_edits_button.disabled = false;
      reset_edits_button.disabled = false;
      reset_edits_button.onclick = ResetClicked;
      edits_done = true;
      }
    else
      {
      // no changes? make sure submit and reset buttons are disabled
      // - this is for the situation where you make a change and then change it back
      submit_edits_button.disabled = true;
      reset_edits_button.disabled = true;
      reset_edits_button.onclick = null;
      edits_done = false;
      }

   }  // if dragok
} // end of onMouseMove

// test if the mouse is inside one of the dragging boxes
function mouseInBox (mousex, mousey, x, y, hsize, vsize)
  {
  if (mousex < (x * width_multiple) - hsize / 2)
    return false;  // too far left
  if (mousex > (x * width_multiple) + hsize / 2)
    return false;  // too far right
  if (mousey < (y * height_multiple) - vsize / 2)
    return false;  // too far up
  if (mousey > (y * height_multiple) + vsize / 2)
    return false;  // too far down
  return true;
  } // end of mouseInBox

// mouse down event - set up for dragging somewhere
function onMouseDown(event)
{
  found = false;
  mousex = event.offsetX;
  mousey = event.offsetY;
//  console.log ("event".concat (' x= ', event.offsetX, ' y= ', event.offsetY));

  // find active element
  for (i = 0; i < num_elements; i++)
    {
    activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);
    // top left?
    if (mouseInBox (mousex, mousey, startX, startY, BOX_SIZE, BOX_SIZE))
      {
      activeCorner = 'topleft';
      found = true;
      break;
      }
    // top right?
    else if (mouseInBox (mousex, mousey, endX, startY, BOX_SIZE, BOX_SIZE) && element_type != ELEMENT_LINE)
      {
      activeCorner = 'topright';
      found = true;
      break;
      }
    // bottom left?
    else if (mouseInBox (mousex, mousey, startX, endY, BOX_SIZE, BOX_SIZE) && element_type != ELEMENT_LINE)
      {
      activeCorner = 'bottomleft';
      found = true;
      break;
      }
    // bottom right?
    else if (mouseInBox (mousex, mousey, endX, endY, BOX_SIZE, BOX_SIZE))
      {
      activeCorner = 'bottomright';
      found = true;
      break;
      }
    // and now check the dragging box
    else if (mouseInBox (mousex, mousey, startX + (endX - startX) / 2, startY, DRAGGING_BOX_SIZE, BOX_SIZE))
      {
      activeCorner = 'drag';
      // remember where we clicked so we can get a delta location
      dragMouseX = mousex;
      dragMouseY = mousey;
      // remember where it was when we clicked
      dragStartX = elements [activeElement] [STARTX];
      dragStartY = elements [activeElement] [STARTY];
      dragEndX   = elements [activeElement] [ENDX];
      dragEndY   = elements [activeElement] [ENDY];
      found = true;
      break;
      }

    } // end of for each element

  if (!found)
    {
//    console.log ("no element found");
    return;
    }

  dragok = true;
  canvas.onmousemove = onMouseMove;  // activate mouse move handler
} // end of onMouseDown

// mouse up handler - cancel ability to drag
function onMouseUp()
  {
  dragok = false;
  canvas.onmousemove = null;   // deactivate mouse move handler
  } // end of onMouseUp

// double-click in an element box edits that element (eg. to change the text)
function onDoubleClick(event)
  {
  mousex = event.offsetX;
  mousey = event.offsetY;

  if (edits_done)
    {
    alert ("You have un-saved position edits - submit them or reset them.");
    return;
    }

  // go backwards so that the higher (on top) one gets selected before the one underneath
  for (i = num_elements - 1; i >= 0; i--)
    {
    activeElement = i;
    // get *this* element
    getElementDetails (elements [i]);

    button_to_click = document.getElementById("link_to_edit_element_".concat (element_id));
    if (!button_to_click)
      return;   // can't find button

    // let them double-click in the title box in case it is hard to find the element (eg. a line)
    if (mouseInBox (mousex, mousey, startX + (endX - startX) / 2, startY, DRAGGING_BOX_SIZE, BOX_SIZE))
      {
      button_to_click.click();    // activate it
      return;
      }

    if (mousex < (startX * width_multiple))
      continue;  // too far left
    if (mousex > (endX * width_multiple))
      continue;  // too far right
    if (mousey < (startY * height_multiple))
      continue;  // too far up
    if (mousey > (endY * height_multiple))
      continue;  // too far down

    // found the element!
    button_to_click.click();    // activate it
    return;
    } // end of for each element

  } // end of onDoubleClick

// START HERE

init ();  // get our canvas and context

// mouse handlers
canvas.onmousedown = onMouseDown;
canvas.onmouseup   = onMouseUp;
canvas.ondblclick  = onDoubleClick;


/*

These lines are added by the PHP file once the "submit_edits_button" button exists,
otherwise the onclick doesn't work.

    submit_edits_button = document.getElementById(\"submit_edits_button\");
    submit_edits_button.onclick = SubmitEditsClicked;

*/
